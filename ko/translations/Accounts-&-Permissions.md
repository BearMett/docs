- [지갑(Wallets)](#지갑Wallets)
- [계정(Accounts)](#계정Accounts)
- [자격과 권한(Authorities and Permissions)](#자격과-권한Authorities-and-Permissions)
- [최종 요약 (Putting it all Together)](#최종-요약-Putting-it-all-Together)
  - [기본 계정 구성 (단일 서명, Single-Sig)](#기본-계정-구성-단일-서명-Single-Sig)
  - [다중 서명 계정 그리고 사용자 지정 권한](#다중-서명-계정-그리고-사용자-지정-권한)
- [번역 정보](#번역-정보)


**계정(account)** 는 블록체인상에 저장된 사람이 읽을 수 있는 형태의 식별자입니다. 모든 트랜잭션 (transaction)의 권한(permission)은 트랜잭션을 일으키는 계정의 자격 구성에 의해 결정됩니다. 각각의 권한은 고유의 이름을 가지고 있습니다. 권한을 결정하는데 있어 임계값 (threshold)이라는 개념이 있습니다. 트랜잭션의 유효하기 위해선 트랜잭션에 필요한 권한값이 (weight) 임계값을 넘었을 때 발생합니다. (역주:원문을 그대로 번역한다면 권한값은 가중치로 번역되겠지만 이해를 돕기위해 이 문서에서는 권한값이라는 표현을 사용하였습니다.) **클라이언트(client)** 프로그램을 통해 지갑(wallet)을 불러오고 잠금을 해제한 뒤 트랜잭션에 서명을 남길 수 있습니다. 지갑은 사용자가 가지고 있는 키를 안전하게 보관하고 사용할 수 있는 소프트웨어입니다. 블록체인 상에서 각 계정에는 여러 키들이 부여될 수 있고 이 키마다 다른 계정에 대한 권한은 해당 계정의 자격 구성에 따라 다를 수 있습니다.

## 지갑(Wallets)

지갑(wallet)은 클라이언트(client)프로그램으로 키들을 저장합니다. 각 키들은 다른 계정의 권한을 가질 수 있습니다. 이상적인 경우, 지갑은 높은 엔트로피의 비밀번호 (역주: 상당히 복잡한 비밀번호)로 보호되는 잠금 상태 (암호화 상태)와 잠금이 해제된 상태(복호화 상태)를 가집니다. EOSIO/eos 저장소의 `keosd`라는 lite-client와 상호작용하는 `cleos`라는 command line interface client가 이러한 패턴을 보여줍니다.

## 계정(Accounts)

계정(account) 는 블록체인상에 저장된, 사람이 읽을 수 있는 이름입니다. 계정의 소유자는 권한 구성에 따라 개인이 될수도 있고 개인들의 그룹이 될수도 있습니다. 블록체인에 트랜잭션를 전송하거나 다른 방식을 통해 실행하는 경우에 계정이 사용됩니다.

## 자격과 권한(Authorities and Permissions)

자격은 통해 어떤 액션의 적합성 여부를 결정할 수 있습니다.

모든 계정은 두 가지 _시스템 권한 (native permission)_을 갖게 됩니다.

- 계정의 소유권을 나타내는 권한으로 `owner` 권한이 있습니다. 극히 일부의 트랜잭션에서 이 권한이 요구되며 대표적으로 소유자 권한을 변경할 때 사용됩니다. 일반적으로 이러한 `owner` 권한의 비밀키는 보안상 콜드스토리지(역주: 외부에 노출될 염려가 없는 저장장치, 종이에 기록, 네트워크가 분리된 저장장치 등)에 저장하고 그 누구와도 공유하지 않는 편이 안전합니다. 또한 이 `owner` 권한은 `owner` 권한이 아닌 다른 권한이 탈취되었을 때 복원 기능을 제공합니다.

- `active` 권한은 `owner` 권한 다음 막강한 권한으로 토큰을 전송, 블록 프로듀서에게 투표를 포함해 비교적 높은 자격이 요구되는 액션에 사용됩니다.

_시스템 권한_ 은 EOSIO에서 부여하는 권한입니다. 이 _시스템 권한_ 이외에, 계정 관리를 용이하게 하기 위해 각 계정은 사용자 지정 권한을 정의할 수 있습니다. 사용자 지정 권한 정의는 상당히 자유로워서, 대다수의 경우를 구현할 수 있습니다. 앞으로 만들어질 권한들은 개발자 커뮤니티가 사용하는 방식, 채택될 규칙 등에 의해 달라질 것으로 예상됩니다.

하나 또는 다수의 유효한 `계정명` 또는 `공개 키`가 각 자격에 대한 권한을 구성하게 됩니다.

## 최종 요약 (Putting it all Together)

다음 내용에서는 실제 적용가능한 몇가지 예시를 포함해 지금까지 소개한 모든 개념을 다룰 예정입니다.


### 기본 계정 구성 (단일 서명, Single-Sig)

계정이 생성되면 기본 권한 구성을 가지게 됩니다. 이 기본 권한 구성 하에서 시스템 권한인 `owner`와 `active` 권한에는 각각 한개의 키가 존재합니다. 이 키들의 권한값은 **1**이며 권한의 임계값 또한 **1**로 동일합니다. 즉 이 구성에서는 `owner`, `active` 자격으로 액션을 실행하기 위해 각각 `owner`, `active` 권한의 단일 서명이 요구됩니다.

#### __*@bob account authorities*__

| Permission | Account                                               | Weight | Threshold |
|------------|-------------------------------------------------------|--------|-----------|
| owner      |                                                       |        | 1         |
|            | EOS5EzTZZQQxdrDaJAPD9pDzGJZ5bj34HaAb8yuvjFHGWzqV25Dch | 1      |           |
| active     |                                                       |        | 1         |
|            | EOS61chK8GbH4ukWcbom8HgK95AeUfP8MBPn7XRq8FeMBYYTgwmcX | 1      |           |

`@bob` 계정의 `owner` 권한에 대해서 `@bob`의 owner key는 1이라는 권한값을 가집니다. `owner` 자격을 얻기위한 임계값은 1로 `@bob`의 owner key 서명만 있다면 `owner` 자격이 필요한 트랜잭션를 일으킬 수 있습니다. 이 owner key는 지갑에 저장될 수 있고 cleos를 통해 사용할 수 있습니다.

### 다중 서명 계정 그리고 사용자 지정 권한

아래의 예시에서 가상의 `@multisig` 계정의 권한 구성이 소개됩니다. `@multisig`계정에서 `owner` 자격 및 `active` 자격은 `@bob`과 `@stacy`의 권한으로 획득할 수 있습니다. `publish` 자격은 유저3명의 권한을 통해 다양한 방식으로 획득할 수 있습니다.

#### __*@multisig account authorities*__

| Permission | Account                                               | Weight | Threshold |
|------------|-------------------------------------------------------|--------|-----------|
| owner      |                                                       |        | 2         |
|            | @bob                                                  | 1      |           |
|            | @stacy 	                                              | 1      |           |
| active     |                                                       |        | 1         |
|            | @bob                                                  | 1      |           |
|            | @stacy 	                                              | 1      |           |
| publish    |                                                       |        | 2         |
|            | @bob                                                  | 2      |           |
|            | @stacy 	                                              | 2      |           |
|            | EOS7Hnv4iBWo1pcEpP8JyFYCJLRUzYcXSqt...                | 1      |           |

이 예시에서, `owner`에 대한 권한은 `@bob`과 `@stacy`가 가지고 있고 각각의 권한값은 **1**입니다. `owner` 자격을 획득하기 위한 임계값은 **2**이기 때문에  `owner` 자격이 필요한 트랜잭션를 일으키기 위해선 `@bob`과 `@stacy` 모두의 서명이 필요하게 됩니다.

`active` 권한 또한 `@bob`과 `@stacy`가 가지고 있으며 각각의 권한값은 **1**입니다. `active` 자격을 얻기 위한 임계값은 1이기 때문에 `active` 자격이 필요한 트랜잭션에는 `@bob` 또는 `@stacy`의 서명만이 필요하게 됩니다.

`publish` 권한은 *사용자 지정 권한* 입니다. 이 예시 에서, 가상의 블로그 dApp에서는 `@multisig`의 `publish` 자격이 있다면 `@multisig` 계정의 블로그에 포스팅을 할 수 있습니다. `publish` 자격을 얻기 위한 임계값은 **2**이고 `@bob`과 `@stacy`의 권한값은 각각 **2**, 공개 키의 권한값은 **1**입니다. 즉 `@bob` 과 `@stacy`는 본인의 서명만으로 `publish` 자격을 획득할 수 있으나, 공개 키의 권한 값(**1**) 은 임계치(**2**)보다 작기 때문에 `publish` 자격을 얻기 위해선 `publish` 권한을 가지고 있는 다른 계정의 서명이 필요합니다.

따라서 `@bob`과 `@stacy`는 `@multisig`의 소유자로 _편집자 또는 관리자_ 정도의 높은 권한을 갖고 있다고 볼 수 있습니다. 이 예시에서는 EOSIO가 권한 시스템을 자유롭게 구성할 수 있음을 보여줍니다. 다만, 예시의 방식은 확장성이 떨어지고 좋지 못한 디자인 패턴을 가지는 한계가 있어 실제 사용되기에는 어려움이 있습니다.

또한, 앞서 기술되었던 바와 같이 권한은 **계정이름**과 **키**로 구성될 수 있습니다. 이 부분은 다소 당연하게 받아들여질 수 있지만, 이로 인해 권한 시스템을 한껏 자유롭게 구성할 수 있습니다.

**관찰 포인트**

- `@bob`과 `@stacy`는 `@multisig` 계정의 소유자임을 명백히 밝힐 수 있습니다.
- 공개키의 경우 `@bob`또는 `@stacy`의 서명이 없이는 `publish` 자격으로 액션을 실행할 수 없습니다.
- `@bob`과 `@stacy`는 다른 서명이 없이도 `publish` 자격으로 액션을 실행할 수 있습니다.

## 번역 정보

* 원문 : https://github.com/eosio/eos/wiki/Accounts%20%26%20Permissions
* 번역 기준 리비전 : b81148e028926ce3db16b2ff45d405c0d1a665ed
